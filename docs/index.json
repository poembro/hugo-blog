[{"categories":["编程语言"],"content":"我的第一个blog post","date":"2024-11-16","objectID":"/test/","tags":["clang-format","Visual Studio","C++"],"title":"test","uri":"/test/"},{"categories":["编程语言"],"content":"问题描述 ","date":"2024-11-16","objectID":"/test/:1:0","tags":["clang-format","Visual Studio","C++"],"title":"test","uri":"/test/"},{"categories":["编程语言"],"content":"test ","date":"2024-11-16","objectID":"/test/:1:1","tags":["clang-format","Visual Studio","C++"],"title":"test","uri":"/test/"},{"categories":["逆向破解"],"content":"从某个版本开始，WPS Office 的 OEM.INI 中所有的配置项都被加密了，本文尝试通过逆向安装程序解析配置项的加密方式。","date":"2024-08-24","objectID":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/","tags":["C++","ASM"],"title":"WPS Office 的 OEM.INI 配置文件加密算法的逆向分析","uri":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"categories":["逆向破解"],"content":"本文简介 众所周知，WPS Office 的安装包是一种套娃结构，从官网下载的安装包经过解压缩会得到一个真正的安装程序和一个 OEM.INI 配置文件，通过修改这个配置文件，我们可以对 WPS 做一些定制并重新封包，但是从某个版本开始，OEM.INI 中所有的配置项都被加密了，所以本文尝试通过逆向安装程序的方式看看它是怎么加密的。 ","date":"2024-08-24","objectID":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/:1:0","tags":["C++","ASM"],"title":"WPS Office 的 OEM.INI 配置文件加密算法的逆向分析","uri":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"categories":["逆向破解"],"content":"动态分析 首先解压出安装程序和配置文件，看了一下是 32 位程序，通过 x32dbg 进行调试。因为配置文件是 INI 格式的，所以我们首先想到，安装程序是否通过 Win32 API 提供的 INI 操作函数读取配置。而 Kernel32.dll 的 GetPrivateProfileStringW 和 GetPrivateProfileStringA 函数可以用来读取配置文件，那么加上断点，运行程序，发现断在了 GetPrivateProfileStringW 处。 通过查阅微软文档，我们得知它的第一个参数是节名，第二个参数是键名，最后一个参数是文件名。 DWORD GetPrivateProfileStringW( [in] LPCWSTR lpAppName, [in] LPCWSTR lpKeyName, [in] LPCWSTR lpDefault, [out] LPWSTR lpReturnedString, [in] DWORD nSize, [in] LPCWSTR lpFileName ); 查看栈信息，这正是我们解压出来的 OEM.INI 文件。 断在了 GetPrivateProfileStringW 处 一路运行到返回，直到回到程序空间，给这个函数打上断点然后重新运行来到函数开头，发现栈里只有明文，看起来加密就是在这个函数里调用的。 回到程序空间 从头单步调试并观察栈和寄存器信息，直到执行 call a.551C30 之后，发现 eax 中出现了密文，看来这个函数就是加密函数了，打上断点，进入查看。 总体加密函数 单步执行并观察这个函数里的调用，发现执行 call a.551F10 之后，返回了一串像是密钥一样的东西，先记下来，继续执行。 密钥获取函数 而这个密钥和明文一起被传入了下一个调用中，这看起来就是加密函数本体了。 加密函数 继续单步，直到执行 call a.692D60 之后，esi 中出现了类似配置文件中的形似 Base64 的密文。 编码函数 最后，执行过几个符号替换之后，密文变成了配置文件中的样子。 符号替换 现在，该静态分析出手了，看看这个加密是用的什么算法吧。 ","date":"2024-08-24","objectID":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/:2:0","tags":["C++","ASM"],"title":"WPS Office 的 OEM.INI 配置文件加密算法的逆向分析","uri":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"categories":["逆向破解"],"content":"静态分析 用 IDA32 打开安装程序，定位到动态调试发现的总体加密函数。 总体加密函数 首先看一下获取密钥的函数 sub_441F10，注意这里的 _Init_thread_header 和结尾的 _Init_thread_footer，这种结构意味着这是一个函数内的静态变量。 静态变量结构 看起来是把一些硬编码的数据进行一些简单转换，但我们已经通过动态调试得到了密钥，就不再分析了。 一些简单转换 接下来是加密算法部分，我们注意到它先对字符串做了 16 字节对齐，然后对 16 - (str_len \u0026 0xF) 也就是 16 字节对齐后空余的部分全部填充了 aligned_str_len - str_len 空余大小作为内容，这种行为与 PKCS5 和 PKCS7 吻合。 加密部分 继续深入查看，这里有两个函数调用。 加密部分函数调用 到了最深处，这就是加密算法了，这里最初判断算法类型的时候用了 GPT，丢给它算法的关键部分，便可判断出这是 AES 算法，而考虑到配置文件的明文和密文是一一对应的，就初步判断这是 ECB 算法了，因为也没看见 IV 相关的参数。 加密算法 接下来是编码函数，进入编码函数后看见有码表，打开一看，便猜测这是标准 Base64 编码。 Base64 码表 现在可以验证猜想了，我们使用 CyberChef 网站，添加一个 AES 加密和 Base64 编码，与动态调试的明文和密文做比对，发现结果一致。 尝试加密 现在就只剩最后一步了，这里看到程序替换掉了 Base64 中的三个符号。 符号替换 这样我们就完整的知道 WPS 的安装程序是如何对配置文件加解密的了，现在只需要写一个转换程序，就可以实现对明文和密文 INI 的转换了。 ","date":"2024-08-24","objectID":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/:3:0","tags":["C++","ASM"],"title":"WPS Office 的 OEM.INI 配置文件加密算法的逆向分析","uri":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"categories":["逆向破解"],"content":"后记 这是我的第一次逆向实战，成功了，很开心。没遇到任何加壳、反调试等措施，加密算法也比较简单，但即使是这样，能成功也有一定的运气因素，不了解的东西实在是太多了呢… ","date":"2024-08-24","objectID":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/:4:0","tags":["C++","ASM"],"title":"WPS Office 的 OEM.INI 配置文件加密算法的逆向分析","uri":"/2024-08-25-wps-office-%E7%9A%84-oem.ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"categories":["逆向破解"],"content":"目前最便宜好用的 NFC 读卡器当属 PN532 模块了，那我们能用它来做些什么呢？（坏笑）","date":"2024-08-24","objectID":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/","tags":["C++","RFID"],"title":"一张水卡的数据解析及利用（M1卡破解）","uri":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/"},{"categories":["逆向破解"],"content":"设备 \u0026 软件 目前最便宜好用的 NFC 读卡器当属 PN532 模块了，将它连接到电脑上还需要一个 TTL 转 USB 工具，这里使用 CH340 转接板。连接好读卡器的串口排线，就可以使用 M1T 等软件尝试解密钥啦。 ","date":"2024-08-24","objectID":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/:1:0","tags":["C++","RFID"],"title":"一张水卡的数据解析及利用（M1卡破解）","uri":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/"},{"categories":["逆向破解"],"content":"解析密钥 \u0026 读取数据 使用 M1T 解析出 IC 卡的 Key B 为 A9 DE 7F 3C EB 1F。 读取数据进行分析，以下是该卡的第 10 和 11 扇区以及 0 扇区的块 0，除此之外的扇区数据均为空。 Section 0 Block 0: 5E E1 6E A4 75 08 04 00 01 DD 54 AF A4 43 D6 1D Section 10 Block 0: 23 0A 01 00 09 F5 00 D6 02 00 5E 00 00 5E 00 62 Block 1: 1B F5 03 EE 04 0A AA 00 A0 01 83 1B 00 9E 00 84 Block 2: 23 0A 01 00 09 F5 00 D6 02 00 5E 00 00 5E 00 62 Block 3: 0A A1 1E 91 5B 81 7F 07 88 69 A9 DE 7F 3C EB 1F Section 11 Block 0: C1 3E 12 2C 00 C1 00 00 00 00 06 00 00 06 00 B6 Block 1: 1B F5 03 EE 04 0A AA 00 A0 01 83 1B 00 9E 00 84 Block 2: C1 3E 12 2C 00 C1 00 00 00 00 06 00 00 06 00 B6 Block 3: 0B A1 1E 91 5B 81 7F 07 88 69 A9 DE 7F 3C EB 1F ","date":"2024-08-24","objectID":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/:2:0","tags":["C++","RFID"],"title":"一张水卡的数据解析及利用（M1卡破解）","uri":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/"},{"categories":["逆向破解"],"content":"分析数据 通过观察发现，这些扇区的 Key A 并不相同，而 Key B 为固定值；并且第 10 扇区和第 11 扇区中块 0 和块 2 的数据相同。 通过多次刷卡发现，第 10 扇区会被刷卡机修改，而第 11 扇区未被使用。 接下来的分析重点将放在 Key A 和第 10 扇区上。 ","date":"2024-08-24","objectID":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/:3:0","tags":["C++","RFID"],"title":"一张水卡的数据解析及利用（M1卡破解）","uri":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/"},{"categories":["逆向破解"],"content":"Key A 的分析 通过观察发现 Key A 的结构如下： 0A A1 1E 91 5B 81 数据位 作用 计算 0A 扇区号 0A A1 1E 91 5B 取反 UID ~5E ~E1 ~6E ~A4 81 固定值 81 ","date":"2024-08-24","objectID":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/:3:1","tags":["C++","RFID"],"title":"一张水卡的数据解析及利用（M1卡破解）","uri":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/"},{"categories":["逆向破解"],"content":"块 0 的分析 通过多次比对数据改动和刷卡机显示的数额，猜测出一些数据位的作用如下： 23 0A 01 00 09 F5 00 D6 02 00 5E 00 00 5E 00 62 数据位 作用 计算 23 异或校验 0A ^ 01 ^ 00 ^ 09 ^ F5 ^ 00 ^ D6 ^ 02 ^ 00 ^ 5E ^ 00 ^ 00 ^ 5E ^ 00 0A 和校验 01 + 00 + 09 01 00 剩余数额 0.01 * 100 F5 和取反校验 ~ (01 + 00 + 09) D6 02 上次使用数额 7.26 * 100 5E 使用次数 62 和取反校验 ~ (0A + 01 + 00 + 09 + F5 + 00 + D6 + 02 + 00 + 5E + 00 + 00 + 5E + 00) 黑色标注的数据猜测为无实际作用的数据。 ","date":"2024-08-24","objectID":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/:3:2","tags":["C++","RFID"],"title":"一张水卡的数据解析及利用（M1卡破解）","uri":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/"},{"categories":["逆向破解"],"content":"块 1 的分析 这里的数据是固定的，不知道用途，但可以猜测出第一位和最后一位为校验位： 1B F5 03 EE 04 0A AA 00 A0 01 83 1B 00 9E 00 84 数据位 作用 计算 1B 异或校验 F5 ^ 03 ^ EE ^ 04 ^ 0A ^ AA ^ 00 ^ A0 ^ 01 ^ 83 ^ 1B ^ 00 ^ 9E ^ 00 84 和取反校验 ~ (F5 + 03 + EE + 04 + 0A + AA + 00 + A0 + 01 + 83 + 1B + 00 + 9E + 00) 通过比对，尝试将不同的数据位置零后也可以正常使用。 ","date":"2024-08-24","objectID":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/:3:3","tags":["C++","RFID"],"title":"一张水卡的数据解析及利用（M1卡破解）","uri":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/"},{"categories":["逆向破解"],"content":"利用 先构建 M1 卡的结构。 // M1Card.h #pragma once #include \u003cstdint.h\u003e typedef struct TM1CardManufacturerBlock { uint32_t UID; uint8_t UIDXorChecksum; uint8_t SAK; uint16_t ATQA; uint8_t ManufacturerInfomation[8]; } M1CardManufacturerBlock, *PM1CardManufacturerBlock; typedef struct TM1CardKeyBlock { uint8_t KeyA[6]; uint8_t AccessBits[4]; uint8_t KeyB[6]; } M1CardKeyBlock, *PM1CardKeyBlock; typedef struct TM1CardSector { union { M1CardManufacturerBlock ManufacturerBlock; uint8_t DataBlock0[16]; }; uint8_t DataBlock1[16]; uint8_t DataBlock2[16]; M1CardKeyBlock KeyBlock; } M1CardSector, *PM1CardSector; void M1Card_SetCardInfomation(PM1CardSector cardData, uint32_t uid, uint8_t sak, uint16_t atqa); 实现 M1 卡制造商信息设置函数。 // M1Card.c #include \"M1Card.h\" void M1Card_SetCardInfomation(PM1CardSector cardData, uint32_t uid, uint8_t sak, uint16_t atqa) { uint8_t* uidData = (uint8_t*) \u0026uid; cardData-\u003eManufacturerBlock.UID = uid; cardData-\u003eManufacturerBlock.UIDXorChecksum = uidData[0] ^ uidData[1] ^ uidData[2] ^ uidData[3]; cardData-\u003eManufacturerBlock.SAK = sak; cardData-\u003eManufacturerBlock.ATQA = atqa; } 然后构建解析出的水卡的结构。 // WaterCard.h #pragma once #include \u003cstdint.h\u003e #include \"M1Card.h\" typedef struct TWaterCardSector { uint8_t OverallXorChecksum; uint8_t AmountSumChecksum; union { uint16_t Amount; struct { uint8_t AmountByte1; uint8_t AmountByte2; }; }; uint8_t Padding1Byte1; uint8_t AmountSumXorChecksum; uint8_t Padding5Bytes[5]; uint8_t UsageCountSum; uint8_t Padding1Byte2; uint8_t UsageCountSumChecksum; uint8_t Padding1Byte3; uint8_t OverallSumXorChecksum; } WaterCardSector, *PWaterCardSector; typedef struct TWaterCardKeyA { uint8_t Index; uint8_t UIDXorChecksum[4]; uint8_t Padding1Byte; } WaterCardKeyA, *PWaterCardKeyA; void WaterCard_SetCard(PM1CardSector cardData, uint32_t uid, uint16_t amount); 最后实现利用函数。 // WaterCard.c #include \u003cstring.h\u003e #include \"WaterCard.h\" void WaterCard_SetKey(PM1CardSector cardData, uint32_t uid) { for (int i = 0; i \u003c 16; i++) { PM1CardKeyBlock key = \u0026cardData[i].KeyBlock; PWaterCardKeyA keyA = (PWaterCardKeyA) \u0026key-\u003eKeyA; uint8_t* uidData = (uint8_t*) \u0026uid; keyA-\u003eIndex = (uint8_t) i; keyA-\u003ePadding1Byte = 0x81; for (int i = 0; i \u003c 4; i++) { keyA-\u003eUIDXorChecksum[i] = ~uidData[i]; } *((uint16_t*) key-\u003eKeyB) = 0xDEA9; *((uint32_t*) (key-\u003eKeyB + 2)) = 0x1FEB3C7F; *((uint32_t*) key-\u003eAccessBits) = 0x6988077F; } } void WaterCard_SetDataSector(PM1CardSector cardData, uint16_t amount) { uint8_t* sectorData = cardData[10].DataBlock0; uint8_t* sectorDataCopy = cardData[10].DataBlock2; PWaterCardSector sector = (PWaterCardSector) sectorData; memset(sector, 0, 16); sector-\u003eAmount = amount; sector-\u003eAmountSumChecksum = sector-\u003eAmountByte1 + sector-\u003eAmountByte2 + sector-\u003ePadding1Byte1; sector-\u003eAmountSumXorChecksum = ~sector-\u003eAmountSumChecksum; for (int i = 1; i \u003c 14; i++) { sector-\u003eOverallXorChecksum ^= sectorData[i]; sector-\u003eOverallSumXorChecksum += sectorData[i]; } sector-\u003eOverallSumXorChecksum = ~sector-\u003eOverallSumXorChecksum; memcpy_s(sectorDataCopy, 16, sectorData, 16); } void WaterCard_SetDataIDSector(PM1CardSector cardData) { uint64_t idData0 = 0x00AA0A04EE03F51D; uint64_t idData1 = 0xC0000000000001A0; uint64_t* sectorData = (uint64_t*) cardData[10].DataBlock1; sectorData[0] = idData0; sectorData[1] = idData1; } void WaterCard_SetCard(PM1CardSector cardData, uint32_t uid, uint16_t amount) { M1Card_SetCardInfomation(cardData, uid, 8, 4); WaterCard_SetKey(cardData, uid); WaterCard_SetDataIDSector(cardData); WaterCard_SetDataSector(cardData, amount); } 测试生成 Dump 文件。 // Main.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \"WaterCard.h\" int main() { size_t size = sizeof(M1CardSector) * 16; PM1CardSector cardData = (PM1CardSector) malloc(size); if (!cardData) { return -1; } // UID: F7-F7-F7-02, Amount: 8.08 WaterCard_SetCard(cardData, 0x02F7F7F7, 0x2803); FILE* file; fopen_s(\u0026file, \"Card.dump\", \"wb\"); if (!file) { free(cardData); return -1; } fwrite(cardData, size, 1, file); fclose(file); free(cardData); return 0; } ","date":"2024-08-24","objectID":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/:4:0","tags":["C++","RFID"],"title":"一张水卡的数据解析及利用（M1卡破解）","uri":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/"},{"categories":["逆向破解"],"content":"写在结尾 ⚠⚠⚠ 本篇文章仅供学习，请勿用于非法用途！⚠⚠⚠ ","date":"2024-08-24","objectID":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/:5:0","tags":["C++","RFID"],"title":"一张水卡的数据解析及利用（M1卡破解）","uri":"/2024-08-24-%E4%B8%80%E5%BC%A0%E6%B0%B4%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8m1%E5%8D%A1%E7%A0%B4%E8%A7%A3/"},{"categories":["编程语言"],"content":"由于一些众所周知的原因，我们不得不使用过时的 VC++ 6.0 来学习 C 语言，那我们就只使用它的编译器吧！","date":"2024-08-24","objectID":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/","tags":["Visual Studio","C++"],"title":"使用 VS Code 作为 Visual C++ 6.0 (VC6) 的编辑器","uri":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["编程语言"],"content":"为什么呢 由于一些众所周知的原因，我们不得不使用经典（过时）的比我们年龄还大的已有 25 年历史的 VC++ 6.0 来学习 C 语言。而对于现在来说，这个经典的 IDE 过于简陋，并且早已不兼容新的操作系统，用它学习早已成为一种折磨。但现代的 C 语言编译环境又无法兼容某些教材或考试的语言逻辑。那…我们就只使用它的编译器吧！ ","date":"2024-08-24","objectID":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/:1:0","tags":["Visual Studio","C++"],"title":"使用 VS Code 作为 Visual C++ 6.0 (VC6) 的编辑器","uri":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["编程语言"],"content":"安置 VC98 编译器工具 预制的工具链打包贴在了文章末尾，可以直接下载使用。 工具链文件从 Visual Studio 6.0 Enterprise (6.00.8168) 中提取，提取步骤放在文章末尾。 将编译器文件放置到一个没有中文和空格的路径，这里我的路径是 E:/Library/VC98。 工具链目录 ","date":"2024-08-24","objectID":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/:2:0","tags":["Visual Studio","C++"],"title":"使用 VS Code 作为 Visual C++ 6.0 (VC6) 的编辑器","uri":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["编程语言"],"content":"配置 VS Code 编辑器环境 安装 C/C++ 插件。 C/C++ 插件 安装 Code Runner 插件。 Code Runner 插件 在自己的项目目录（想放哪就放哪qwq）建立一个新目录作为工作区存放需要用 VC6 编译的 C 语言文件，这里我放在了桌面 D:\\Desktop\\VC6_C。 项目目录 在工作区中新建 .vscode 目录，并在其中新建 settings.json，内容为： { \"C_Cpp.default.includePath\": [ // VC98编译器所在路径/INCLUDE \"E:/Library/VC98/INCLUDE\" ], \"code-runner.executorMap\": { // VC98编译器所在路径/VC98.BAT \"c\": \"cd $dir \u0026\u0026 E:/Library/VC98/VC98.BAT CL $fileName /nologo \u0026\u0026 $dir$fileNameWithoutExt\", // VC98编译器所在路径/VC98.BAT \"cpp\": \"cd $dir \u0026\u0026 E:/Library/VC98/VC98.BAT CL $fileName /nologo \u0026\u0026 $dir$fileNameWithoutExt\" } } 在工作区中新建一个测试 C 文件，右键 Run Code 运行。 右键运行 运行结果在底部终端窗口显示。 运行结果 ","date":"2024-08-24","objectID":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/:3:0","tags":["Visual Studio","C++"],"title":"使用 VS Code 作为 Visual C++ 6.0 (VC6) 的编辑器","uri":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["编程语言"],"content":"提取和制作 VC98 编译器工具（如果你感兴趣） ","date":"2024-08-24","objectID":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/:4:0","tags":["Visual Studio","C++"],"title":"使用 VS Code 作为 Visual C++ 6.0 (VC6) 的编辑器","uri":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["编程语言"],"content":"提取编译器文件 下载 Visual Studio 6.0 Enterprise (6.00.8168)，得到 Visual Studio 6.0 Enterprise (6.00.8168).7z 并解压出其中的 VSE600ENU1.ISO 文件。 解压出 VSE600ENU1.ISO 中的 VC98\\BIN，VC98\\INCLUDE，VC98\\LIB 目录和 COMMON\\MSDEV98\\BIN\\MSPDB60.DLL 文件。 将 MSPDB60.DLL 文件复制到解压出的 VC98\\BIN 中。 现在我们得到了以下目录 VC98 ├───BIN ├───INCLUDE └───LIB ","date":"2024-08-24","objectID":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/:4:1","tags":["Visual Studio","C++"],"title":"使用 VS Code 作为 Visual C++ 6.0 (VC6) 的编辑器","uri":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["编程语言"],"content":"编写编译脚本 这里直接使用 BIN 下的编译器是找不到头文件和库文件的，因为原始的 VC++ 6.0 软件在调用编译器时会设置 INCLUDE 和 LIB 环境变量，所以我们通过脚本包装编译命令。 VC98.BAT \u003c编译工具\u003e [参数] @ECHO OFF SET INCLUDE=%~DP0INCLUDE SET LIB=%~DP0LIB FOR /F \"TOKENS=1* DELIMS= \" %%I IN (\"%*\") DO \"%~DP0BIN\\%%I\" %%J ","date":"2024-08-24","objectID":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/:4:2","tags":["Visual Studio","C++"],"title":"使用 VS Code 作为 Visual C++ 6.0 (VC6) 的编辑器","uri":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["编程语言"],"content":"资源下载 预制工具链下载（密码：YUKI） ","date":"2024-08-24","objectID":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/:5:0","tags":["Visual Studio","C++"],"title":"使用 VS Code 作为 Visual C++ 6.0 (VC6) 的编辑器","uri":"/2024-08-24-%E4%BD%BF%E7%94%A8-vs-code-%E4%BD%9C%E4%B8%BA-vc6-%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"关于poembro","date":"2024-08-23","objectID":"/about/","tags":null,"title":"关于poembro","uri":"/about/"},{"categories":null,"content":"简介 一只雪白的幼狐~ 在冬日的暖阳下睡着懒觉、奔跑玩耍… 好似永远也不会长大。 ","date":"2024-08-23","objectID":"/about/:1:0","tags":null,"title":"关于poembro","uri":"/about/"},{"categories":["编程语言"],"content":"让 Visual Studio 默认使用我们自定义的 C/C++ 代码格式化样式，而不需要在项目中创建 .clang-format 文件。","date":"2024-08-23","objectID":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/","tags":["clang-format","Visual Studio","C++"],"title":"Visual Studio 使用 clang-format 自定义 C++ 代码默认格式化样式","uri":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/"},{"categories":["编程语言"],"content":"问题描述 Visual Studio 的 C++ 代码格式化可选使用 clang-format，但它只提供默认样式，如果想使用自定义样式则需要在每个项目目录下放一个 .clang-format 或 _clang-format 文件，没有对全部项目通用的可自定义样式。 ","date":"2024-08-23","objectID":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/:1:0","tags":["clang-format","Visual Studio","C++"],"title":"Visual Studio 使用 clang-format 自定义 C++ 代码默认格式化样式","uri":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/"},{"categories":["编程语言"],"content":"解决方法 这里发现 Visual Studio 的格式设置中有一个使用自定义 clang-format.exe 文件选项，所以这里尝试制做一个 clang-format 的包装程序让 VS 使用（来骗）。 包装程序通过其同级目录下的 rules.txt 文件来设置自定义的默认样式，具体设置参照 Clang-Format 官方文档，也可以使用 Clang-Format 交互式构建器。启用这个包装程序后， Visual Studio 内置的默认格式设置样式选项将会失效。 预编译的包装程序和 clang-format.exe 一起打包贴在了文章末尾，可以直接下载使用。 包装程序的代码贴在了文章末尾，如有需要在 Visual Studio 中使用 Std C++17 编译即可。 clang-format.exe 可以在 %VS安装目录%\\VC\\Tools\\Llvm\\x64\\bin 目录中找到，也可以在 LLVM 发布页 下载。 这里贴上作者习惯使用的代码格式化样式（Java 代码的习惯样式），以下是 rules.txt 内容： # 基于GNU格式 BasedOnStyle: GNU # 使用支持的最新标准 Standard: Latest # 行不限制长度 ColumnLimit: 0 # 缩进4个空格 IndentWidth: 4 # 左花括号在名称之后 BreakBeforeBraces: Attach # 函数参数的小括号与函数名间不空格, 控制语句的小括号与语句间空格 SpaceBeforeParens: ControlStatements # 换行时将二元运算符置后 BreakBeforeBinaryOperators: None # 允许空的花括号在一行上 AllowShortBlocksOnASingleLine: Empty # 函数返回值与函数在同一行 AlwaysBreakAfterDefinitionReturnType: None AlwaysBreakAfterReturnType: None # 指针符号贴在类型边 PointerAlignment: Left # 访问修饰符贴在左边 AccessModifierOffset: -4 # case和default之前缩进 IndentCaseLabels: true # C式类型转换中间留空格 SpaceAfterCStyleCast: true # 类继承冒号之前不留空格 SpaceBeforeInheritanceColon: false # 构造函数初始化冒号之前不留空格 SpaceBeforeCtorInitializerColon: false # 命名空间全部缩进 NamespaceIndentation: All # 不排序头文件引用 SortIncludes: Never # C++11式初始化对象花括号前留空格 SpaceBeforeCpp11BracedList: true ","date":"2024-08-23","objectID":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/:2:0","tags":["clang-format","Visual Studio","C++"],"title":"Visual Studio 使用 clang-format 自定义 C++ 代码默认格式化样式","uri":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/"},{"categories":["编程语言"],"content":"使用之前（二选一） 确保 clang-format.exe 在 PATH 中并且可访问。 PATH 中可访问的 clang-format 确保 clang-format.exe 位于 clang-format-wrapper.exe 的同级目录下。 同级目录下的 clang-format ","date":"2024-08-23","objectID":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/:3:0","tags":["clang-format","Visual Studio","C++"],"title":"Visual Studio 使用 clang-format 自定义 C++ 代码默认格式化样式","uri":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/"},{"categories":["编程语言"],"content":"使用方法 启用 ClangFormat 支持并使用自定义 clang-format.exe 文件，选择上一步的 clang-format-wrapper.exe 并确定。 配置选项 现在可以回到编辑器测试一下了，默认格式化快捷键是 Ctrl + K + D。 ","date":"2024-08-23","objectID":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/:4:0","tags":["clang-format","Visual Studio","C++"],"title":"Visual Studio 使用 clang-format 自定义 C++ 代码默认格式化样式","uri":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/"},{"categories":["编程语言"],"content":"包装程序的代码 #include \u003cfilesystem\u003e #include \u003coptional\u003e #include \u003cstring\u003e #include \u003cprocess.h\u003e namespace fs = std::filesystem; const wchar_t* clang_format_path = L\"clang-format.exe\"; const wchar_t* rule_text_path = L\"rules.txt\"; int wmain(int argc, wchar_t** argv) { std::optional\u003cstd::wstring\u003e args; fs::path path = fs::absolute(argv[0]); path.replace_filename(clang_format_path); if (fs::exists(path)) { args = path.wstring(); } else { args = std::wstring(clang_format_path, 16); } args-\u003epush_back(L' '); for (int i = 1; i \u003c argc; i++) { if (!wcsstr(argv[i], L\"-style=\")) { args-\u003eappend(argv[i]); args-\u003epush_back(L' '); } } args-\u003eappend(L\"-fallback-style=none -style=file:\"); args-\u003eappend(path.replace_filename(rule_text_path)); return _wsystem(args-\u003edata()); } ","date":"2024-08-23","objectID":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/:5:0","tags":["clang-format","Visual Studio","C++"],"title":"Visual Studio 使用 clang-format 自定义 C++ 代码默认格式化样式","uri":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/"},{"categories":["编程语言"],"content":"资源下载 由于 clang-format.exe 和 clang-format-wrapper.exe 依赖 VC++ 140 运行库，如果无法运行请先安装运行库。 运行库合集下载（密码：YUKI） 预编译程序下载（密码：YUKI） ","date":"2024-08-23","objectID":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/:6:0","tags":["clang-format","Visual Studio","C++"],"title":"Visual Studio 使用 clang-format 自定义 C++ 代码默认格式化样式","uri":"/2024-08-23-visual-studio-%E4%BD%BF%E7%94%A8-clang-format-%E8%87%AA%E5%AE%9A%E4%B9%89-c-%E4%BB%A3%E7%A0%81%E9%BB%98%E8%AE%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F/"}]